# 计算机基础

最后编辑于23-9-3

本文会涉及计算机的组成，以及一些关于二进制的知识

## 二进制

**编写代码不需要你会二进制，不需要你直接写二进制，但是这一部分仍然很有必要**

**概念本身就需要理解，觉得困难是合理的，也欢迎提出你看时的感受来让我改进这里，造福后来人**

### 进制

想必你一定学过数学，知道数字，比如说

* 自然数 $123456$
* 小数   $114.514$
* 负数   $-191810$

我们学的数字遵循**逢十进一**，什么意思呢

$9 + 1 = 10$，这就是**进位**，9是一个一位数，1也是，它们相加的结果是一个个位为0的两位数

如果只看个位，$9 + 1$ 得到了 $0$，最小的个位数 ~~不涉及负数~~

那么比9加1实际上的结果，表现在十位上，也就是$10$中的$1$

这便是**逢十进一**的**十进制数**

那么，如果一个数字逢n进一，就称之为n进制数

计算机内部使用的是二进制数字，遵循逢二进一

也就是说，二进制加法是这样的：$1 + 1 = 10$

注意这里的$1$不是十进制的$1$，$10$也不是十进制的$10$

二进制10 转换为 十进制其实就是2

通过给数字添加下标来分辨进制:

$110110_2$ 是二进制数，而$54$是十进制数字

### *进制转换

实际上数字可以这样拆分，比如对于一个十进制数字6574

$6574 = 6 * 10 ^ 3 + 5 * 10 ^ 2 + 7 * 10 ^ 1 + 4 * 10 ^ 0 = 6574$

~~好像什么都没发生？~~

那么对于$110110_2$，可以这样拆分

*为了方便观看我加上了括号*

$110110_2 = (1 * 2 ^ 5) + (1 * 2 ^ 4) + (0 * 2 ^ 3) + (1 * 2 ^ 2) + (1 * 2 ^ 1) + (0 * 2 ^ 0) = 32 + 16 + 4 + 2 = 54$

也就是说，$110110_2$就表示$54$，观察规律，这就是二进制转十进制的方法

那么同样的，将一个十进制数转换为一系列 一个数乘以2的一个次方式子 的和，就可以转换得到二进制

比如说$54 = (1 * 2 ^ 5) + (1 * 2 ^ 4) + (0 * 2 ^ 3) + (1 * 2 ^ 2) + (1 * 2 ^ 1) + (0 * 2 ^ 0) = 110110_2$

那么，这个转换是怎么进行的呢？一眼看不出来啊

其实很简单


*后面的 ....... 表示的是余数*

$27 / = 27 ...... 0$

$27 / 2 = 13 ...... 1$

$13 / 2 = 6  ...... 1$

$6  / 2 = 3  ...... 0$

$3  / 2 = 1  ...... 1$

$1  / 2 = 0  ...... 1$

那么从下往上查看余数，就是110110

其中原理自行体会，~~这个转换的方法只是了解一下而已，不是必须的，你看这一部分叫 *进制转换~~

## 数据类型

计算机内部的数字都是单纯的二进制数字，甚至没有符号，更没有小数点。毕竟成天面对一堆数字是不可能的，那不是人那是神仙。单纯的使用正整数，怎么表示各种东西呢

其实只需要**赋予数字意义**就可以

比如说，给数字加上单位，数字就有了”实际意义“，1只是1，而1m就可以表示一个现实中的长度

那么一样，给二进制数字加上”单位”。就可用二进制数字来表示各种东西。不过不同的是，这个“单位”甚至会改变其运算规则

这个“单位”就叫做**数据类型**

给数据标注上类型，CPU会根据数据类型处理数据

即使两个数据的二进制表示完全相同，它们的类型不同，它们的”含义“就不同

### 无符号整数类型

这个类型不改变任何东西，因为单纯的二进制就是**无符号整数类型**，它的运算也是正常的二进制运算

### 有符号整数类型

对于一个数字$100000001_2$，直接进行转换，它表示十进制的128

但是如果把二进制数字最高的一位，当成正负号，$1$表示负数，$0$表示正数，二进制数字就可以被用来表示负数了。那么

$100000001_2$就表示 $-126$。你可能对此感到困惑，怎么看都不像啊

但是就像前面说的，这个“单位”甚至会改变运算规则，它表示-126也是有原因的：

如果用$01111110_2$也就是$126$加上$-126$可以得到什么呢？

~~这个的Latex我不会写~~

```
  10000001
+ 01111110
-----------
  11111111
```

看起来还是很奇怪，但是不要着急，再给它加上1，也就是00000001你就知道一切是多么巧妙

```
  11111111
+ 00000001
------------
 100000001
```

如果忽略第九位的1，结果就是1：$-126 + 126 + 1 = 1$，很合理吧？

毕竟计算机的数字必须有个长度(工程上不允许 ~~但是逻辑上的实现是另一回事~~)，一个八位数字的第九位会被忽略，最后的结果不会是$100000001$，而是就是$00000001$。这个运算的过程，和结果，实际上是完全合理的

这个类型就叫做`有符号整数类型(integer)`，而这套机制叫做`补码`

其实你仔细看，这套机制**并没有**改变数字的运算规则，有符号整数类型的运算规则和无符号整数类型一模一样，这仅仅是从另一个角度去看待二进制数字

### 浮点数

目前为止，你已经知道了如何用二进制表示一个整数

那么，怎么用二进制表示一个小数呢？

如果你了解一些无穷级数的知识，你一定知道这个

<center>

$\sum_{n=1}^{\infty}2^{-n}=1$

</center>


那么，如果二进制的第$n$位不再是$2^{n-1}$而是$2^{1-n}$，就可以使用二进制来表示小数了

比如1就可以表示 1,而11表示1.5,111就可以表示1.75

*提示：$a^{-b}=\frac{1}{a^b}$*


$1_2   = 1 * 2 ^ 0 = 1$

$11_2  = 1 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.5$

$111_2 = 1 * 2 ^ {-2} + 1 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.75$

$101_2 = 1 * 2 ^ {-2} + 0 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.25$

$100_2 = 1 * 2 ^ {-2} + 0 * 2 ^ {-1} + 0 * 2 ^ 0 = 0.25$

$111111...._2 = 1 + 1/2 + 1/4 + 1/16 + ... = 2$

但是想必你已经发现了一些问题：

1. 这样只能表示$[1,2)$的数字（为什么是半开半闭区间：计算机不会有无限位用来放差的那$2^{-n}$，距离2永远差那么一点点），然而实际上需要表示一个很大的数字

2. 别说无限位，就算用很大的位数也是不合实际的，这样就会有一点点误差（$0.1 + 0.2 \ne 0.3$很大可能是真命题，因为差了那么一点点）

3. 对于无理数[~~超纲了~~](../intro.md#对读者的要求)我只能说，**无能为力**，$\pi，e$这样的都只能取一个近似的浮点数

4. 算浮点数有点慢

对于第四个问题，它设计是这么复杂的，没办法（

有的地方不需要小数，就别用浮点数了~

对于第二个问题，只能说：这是设计缺陷

但是对于第一个问题，结合一下小学知识：科学计数法，可以很好地解决

*对于一个数字$n$,可以使用科学计数法表示为$n = a * p^b$ ~~原话是什么我忘了~~*

比如说$123456 = 1.23456 * 10^5$

那么分别用两个二进制数表示其中的$a$和$b$，就可以表示相当多，相当大和相当小

那么，糅杂在一起，就构成了浮点数类型

一个32位的浮点数，其中的1位是**符号位**（表示正负），10位是**指数**（也就是b的部分，底也就是p等于2），11位是**尾数**（也就是a的部分）

~~这个具体多长你不用记，几乎用不上，仅仅了解下就可以~~

为什么要这样规定呢？如果没有规定，底数（p）是多少？多长是**尾数**？多长是**指数**？有没有**符号位**？都会是一个问题，甚至会出现不同的CPU的设计不同，导致运算精度，可以表示的数字的范围不一样，这会是很麻烦的事

### 字符类型

~~其实很简单，一个数字对应一个字，就这么简单粗暴~~

字符是没规律的，没法用一个数字计算得到一个字符

那么要表示一个字符，就只能用类似”密码“的方法

用数字的一种唯一的排列组合，来对应一个文字

字符到数字叫做编码，数字到字符叫做解码

所以我就简单介绍下两种字符集（对应的标准）

而字符集和实现叫做字符编码（了解一下就可以了）

#### ascii

*美国信息交换用标准代码（全写为 American Standard Code for Information Interchange，使用不同程序的计算机可互相传送数据的一种标准码）*

ascii使用一个7位的二进制数字来表示一个字母，符号，或者别的，它占用的空间很小，每个ascii字符也用相同的空间，但是代价是可以表示的东西非常有限（常用中文都有几千个呢）

它存在的意义？它够简单，而且是一个标准，后来的高级的编码也都支持它

#### Unicode

当今世界上最流行的字符集

它可以表示相当多的字符，毕竟你看到的这个页面用的就是Unicode

Unicode可以表示八国文字，八国符号，😊emoji等等很多

为了节省空间，Unicode字符集有三个字符编码，分别是UTF-8，UTF-16，UTF-32

后面的数字表示的是这个字符使用空间的大小（二进制位数）

UTF32编码可以用一个32位的数字表示全部Unicode字符，而另两种则是看具体字符使用不一样大的空间来表示

#### 扩展阅读

不同操作系统内部使用的是不同的字符编码，这很恶心，但是rust内部的`str`和`String`类型使用的是UTF-8，`char`使用的是UTF-32，`OsString`使用的是操作系统的字符编码，rust提供它们之间的转换，这使得你在移植rust程序时不需要考虑这方面的问题

## 计算机组成

这是一个相当复杂的话题，所以我只能说**需要的一部分**

### 程序

计算机，计算，你的程序就是使唤CPU计算

### 机器指令

CPU只可以运行最简单的指令，称之为**机器指令**，CPU会根据具体指令使唤CPU各个部分干活

~~或许你可以把指令也理解为一种数据类型？~~

机器指令大概是这样的

*机器指令实际上也是二进制的数据，但是为了简化，我就用文字表达*

```
把在xx的数据拿到a1上
把在yy的数据拿到a2上
计算a1，a2的和（保存到a1）
把a1的数据保存到xx
```

这样，如果xx位置上有1，yy位置上有4，执行完之后xx位置就会变成5

那么问题来了：为什么要多此一举？

### 寄存器

为什么要把数据从xx拿到a1，从yy拿到a2，再计算呢？

首先，xx，yy这里指的是**内存**，a1，a2这里指的是**寄存器**

内存就是所谓的内存条带给计算机的，用来存放数据的地方，手机参数中的“8G+256G”前面的8G代表的就是内存的大小

8G的内存（理论上）可以存放$8 * 1024 * 1024 * 1024$个byte

*1 byte = 8 bit，也就是一个8位的二进制数据*

CPU在运行时需要有地方可以存放很多数据，供给使用，这就是内存的作用。

就像你算数字，需要一个草稿纸写下一些东西，不然你需要时就得重新计算 ~~然后再忘掉前面计算的~~

但也像你算数一样，并不是所有数字都在草稿纸上，你大多时候是心算数字，然后记录在草稿纸上。有的数字被你记忆在大脑中，真正参与你大脑的运算

小学学的竖式乘法，它实际上是把大数乘法分解成一个个小数字的乘法，加法，然后让你熟练使用加法，乘法法则计算。草稿纸上也会写有一堆数字，你的大脑计算时脑海中也是一个个小数字

而CPU对应人脑记忆的位置，就是**寄存器**

寄存器很小，很少，只能放一点点数字，但是这是运算必不可少的

你可能会反驳我说，计算机的数字都是数据，都是电流，为什么不能直接用内存放所有数据呢？

实际上，你的大脑也大可不必在脑海中放一些数据，你可以算一个数字写一个数字，而不是连续计算一些数字，然后写下一个数字。

* 连续计算：$12 * 12 = 24 + 120 + 144$

* 逐个计算：~~这不是数学的大括号~~

$$
12 * 12 = \begin{cases}
  12 * 2 = 24 \\
  12 * 10 = 120 \\
  24 + 120 = 144 
\end{cases} = 144
$$

实际上，$12 * 2$ 和 $12 * 10$ 可能需要进一步拆分，因为这也利用到了大脑的记忆，因为你对于 $1$ 和 $2$ ，逐个乘了$2$然后求和才得到的$24$。即使是使用改变$12$的每一位为原来数字的两倍这个方法，你也利用了大脑的记忆，而不是仅仅计算数字

你可能还没发现问题所在，而或者问题就是寄存器真正的意义

**速度**

在草稿本上读写，很慢，但是在大脑内部相当快

```
草稿纸上的数字 -> 眼睛 -> 大脑皮层 -> 解析 -> 脑海中的数字
脑海中的数字 -> 大脑皮层生成写的动作 -> 脊椎控制身体 -> 手部肌肉 -> 草稿纸上的数字
```

同样的，使用在寄存器的数据远远比使用内存中的数据快

所以才需要将数据放到寄存器，再操作

为什么不让寄存器和内存一样大？工程上做不到，而且内存的扩展性也没了。不过现代CPU内部是有**缓存**的，缓存比内存快，比寄存器慢

~~不过手机使用的方案：soc是将CPU，内存等原件集成在一块....不过逻辑上也是内存的逻辑~~

### 内存

*有点超纲了*

内存很大，就像前面说的，8G的内存（理论上）可以存放$8 * 1024 * 1024 * 1024$个byte。为了确切表示某个数据，使用的是一个**内存地址**

可以把内存想象成一本书，那么内存地址就是它的页码，根据页码可以准确地得到想要的数据

而内存地址实际上就是一个数字（很简单粗暴），一个数字对应一个位置，在代码中使用这个数字就可以取得数据

**但是这个数字（内存地址）具体是多少，是不重要的。除非是非常非常底层的程序，将数字转换成内存地址并且使用这个地址是一个UB(之后会隆重介绍)，产生的后果无法预料。且因为操作系统，程序中得到的内存地址并不是真正的内存地址**

目前只需要知道这个概念就可以了，内存是一个很复杂的话题，之后再介绍

寄存器不同于内存，每个寄存器都有自己的名字，只能通过名字使用寄存器

### 核心

CPU为了执行指令，有这样两个模块 ~~名字不用记~~

1. Processing Unit（运算处理单元），简称PU
2. Architectual State（架构状态单元），简称AS

PU负责进行运算，实际上的算数运算就进行在这里。AU负责调度，也就是使唤PU干活

比如有一个小饭店，有一个服务员和一个厨师。排成队的客人会一个个说“来份热干面”，那么服务员就会把信息传递给厨师，厨师就开始煮面，拌酱。这里，服务员就是AS，负责调控，而厨师就是PU，真正干实事的

这一个饭店就是一个**核心**，核心运行各种指令（接待客人）

如果把饭店看成一个CPU，这就是一个**单核CPU**

不过，如果或者饭店有点大，有好几个厨师，好几个服务员，这就是一个**多核心CPU**，这个饭店可以同时接待好条队伍的客人

假如有4个服务员4个厨师，这就是一个4核4线程CPU（4C4T）(Core,Thread)

### *超线程

同样是饭店的例子，不是每个客人都是点餐，有的可能是问价钱，有的可能是问卫生纸在哪。如果服务员一直接待这样的客人，厨师就有机会摸鱼

但是，不行！每个厨师配两个服务员，这样厨师就会很忙，就没时间摸鱼了。这样，只有一个PU，但是有两个AS，可以接待两条队伍的客人

这就是**超线程技术(HT)**，这样就会有4核8线程这样的CPU

超线程可以有效提升性能和并行处理能力，但是单核性能就会变差些（毕竟是两个AS公用一个PU），而且功耗也会提升 ~~请服务员不要钱啊？~~

也不要有功耗焦虑，现在的CPU很成熟了，而且谁家CPU ~~厨师~~ 天天高强度运算

### 输入输出设备

~~如果你可以手动读取，修改内存，从一个个数字脑补出数据，你是神~~

CPU都是连接了外围设备的 ~~不然就是它自嗨~~

比如鼠标，键盘，就属于输入设备

显示器，扬声器就属于输出设备

**可以去读下一节了！**