# 计算机基础

最后编辑于23-9-3

本文会涉及计算机的组成，以及一些关于二进制的知识

## 二进制


### 进制

想必你一定学过数学，知道数字，比如说

* 自然数 $123456$
* 小数   $114.514$
* 负数   $-191810$



我们学的数字遵循**逢十进一**，什么意思呢

$9 + 1 = 10$，这就是**进位**，9是一个一位数，1也是，它们相加的结果是一个个位为0的两位数

如果只看个位，$9 + 1$ 得到了 $0$，最小的个位数 ~~不涉及负数~~

那么比9加1实际上的结果，表现在十位上，也就是$10$中的$1$

这便是**逢十进一**的**十进制数**

那么，如果一个数字逢n进一，就称之为n进制数

计算机内部使用的是二进制数字，遵循逢二进一

也就是说，二进制加法是这样的：$1 + 1 = 10$

注意这里的$1$不是十进制的$1$，$10$也不是十进制的$10$

二进制10 转换为 十进制其实就是2

通过给数字添加下标来分辨进制:

$110110_2$ 是二进制数，而$54$是十进制数字

### *进制转换

实际上数字可以这样拆分，比如对于一个十进制数字6574

$6574 = 6 * 10 ^ 3 + 5 * 10 ^ 2 + 7 * 10 ^ 1 + 4 * 10 ^ 0 = 6574$

~~好像什么都没发生？~~

那么对于$110110_2$，可以这样拆分

*为了方便观看我加上了括号*

$110110_2 = (1 * 2 ^ 5) + (1 * 2 ^ 4) + (0 * 2 ^ 3) + (1 * 2 ^ 2) + (1 * 2 ^ 1) + (0 * 2 ^ 0) = 32 + 16 + 4 + 2 = 54$

也就是说，$110110_2$就表示$54$，观察规律，这就是二进制转十进制的方法

那么同样的，将一个十进制数转换为一系列 一个数乘以2的一个次方式子 的和，就可以转换得到二进制

比如说$54 = (1 * 2 ^ 5) + (1 * 2 ^ 4) + (0 * 2 ^ 3) + (1 * 2 ^ 2) + (1 * 2 ^ 1) + (0 * 2 ^ 0) = 110110_2$

那么，这个转换是怎么进行的呢？一眼看不出来啊

其实很简单


*后面的 ....... 表示的是余数*

$27 / = 27 ...... 0$

$27 / 2 = 13 ...... 1$

$13 / 2 = 6  ...... 1$

$6  / 2 = 3  ...... 0$

$3  / 2 = 1  ...... 1$

$1  / 2 = 0  ...... 1$

那么从上到下查看余数，就是110110

其中原理自行体会，~~这个转换的方法只是了解一下而已，不是必须的，你看这一部分叫 *进制转换~~

## 数据类型

计算机内部的数字都是单纯的二进制数字，甚至没有符号，更没有小数点。毕竟成天面对一堆数字是不可能的，那不是人那是神仙。单纯的使用正整数，怎么表示各种东西呢

其实只需要**赋予数字意义**就可以

比如说，给数字加上单位，数字就有了”实际意义“，1只是1，而1m就可以表示一个现实中的长度

那么一样，给二进制数字加上”单位”。就可用二进制数字来表示各种东西。不过不同的是，这个“单位”甚至会改变其运算规则

这个“单位”就叫做**数据类型**

### 无符号整数类型

这个类型不改变任何东西，因为单纯的二进制就是**无符号整数类型**，它的运算也是正常的二进制运算

### 有符号整数类型

对于一个数字$100000001_2$，直接进行转换，它表示十进制的128

但是如果把二进制数字最高的一位，当成正负号，$1$表示负数，$0$表示正数，二进制数字就可以被用来表示负数了。那么

$100000001_2$就表示 $-126$。你可能对此感到困惑，怎么看都不像啊

但是就像前面说的，这个“单位”甚至会改变运算规则，它表示-126也是有原因的：

如果用$01111110_2$也就是$126$加上$-126$可以得到什么呢？

~~这个的Latex我不会写~~

```
  10000001
+ 01111110
-----------
  11111111
```

看起来还是很奇怪，但是不要着急，再给它加上1，也就是00000001你就知道一切是多么巧妙

```
  11111111
+ 00000001
------------
 100000001
```

如果忽略第九位的1，结果就是1：$-126 + 126 + 1 = 1$，很合理吧？

毕竟计算机的数字必须有个长度(工程上不允许~~但是逻辑上的实现是另一回事~~)，一个八位数字的第九位会被忽略，最后的结果不会是$100000001$，而是就是$00000001$。这个运算的过程，和结果，实际上是完全合理的

这个类型就叫做`有符号整数类型(integer)`，而这套机制叫做`补码`

其实你仔细看，这套机制**并没有**改变数字的运算规则，有符号整数类型的运算规则和无符号整数类型一模一样，这仅仅是从另一个角度去看待二进制数字

### 浮点数

目前为止，你已经知道了如何用二进制表示一个整数

那么，怎么用二进制表示一个小数呢？

如果你了解一些无穷级数的知识，你一定知道这个

<center>

$\sum_{n=1}^{\infty}2^{-n}=1$

</center>


那么，如果二进制的第n位不再是2^(n-1)而是2^(1-n)，就可以使用二进制来表示小数了

比如1就可以表示 1,而11表示1.5,111就可以表示1.75

*提示：$a^{-b}=\frac{1}{a^b}$*



$1_2   = 1 * 2 ^ 0 = 1$

$11_2  = 1 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.5$

$111_2 = 1 * 2 ^ {-2} + 1 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.75$

$101_2 = 1 * 2 ^ {-2} + 0 * 2 ^ {-1} + 1 * 2 ^ 0 = 1.25$

$111111...._2 = 1 + 1/2 + 1/4 + 1/16 + ... = 2$



